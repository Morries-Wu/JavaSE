继承Thread类
1、创建:继承Thread+重写run方法
2、启动:创建子类对象+start
    new Test().start();

实现Runnable接口[推荐]
1、创建:实现接口Runnable+重写run方法
2、启动:创建实现类对象+Thread对象+start
    new Thread(new Test()).start();

实现Callable接口

线程状态
1、新生状态
2、就绪状态
3、运行状态
4、死亡状态

开辟多线程,每个线程都有自己的工作空间,工作空间与主存打交道

线程优先级priority
线程的优先级用数字表示,范围从1到10
优先级低只是意味着获得调度的概率低,并不是绝对先调用优先级高后用优先级低的线程
设置优先级一定要在启动之前

守护线程:是为用户线程服务的:jvm停止不用等待守护线程执行完毕
默认用户线程:jvm等待用户线程执行完毕才停止

多线程并发线程同步
并发:同一个对象多个线程同时操作
线程不安全:数据有负数,和相同情况
synchronized:只能锁一个

死锁:过多的同步可能造成互相不释放资源
从而互相等待,一般发生于同步中持有多个对象的锁
避免:不要在同一个代码块中,同时持有多个对象的锁

并发协作:生产者消费者模式(管程法、信号灯法)
线程同步问题,生产者和消费者共享同一个资源
并且生产者和消费者之间相互依赖,互为条件
概率性优先级不代表绝对的先后顺序,优先级只能用数字1-10

wait:表示线程一直等待,直到其他线程通知,与sleep不一样,会释放锁
yiled:礼让线程,让当前正在执行线程暂停,不是阻塞线程，而是将线程从运行状态转入就绪状态
notify:唤醒一个处于等待状态的线程
notifyAll:唤醒同一个对象上所有调用wait()方法的线程,优先级别高的线程优先调度
均是java.lang.Object类的方法,只能在同步方法代码块中使用,否则会抛出异常


任务定时调度:通过Timer和Timetask,可以实现定时启动某个线程
java.util.Timer:类似闹钟的功能,本身实现的就是一个线程
java.util.TimerTask:一个抽象类,该类实现了Runnable接口,所以该类具备多线程的能力

Quartz:任务调度框架
Scheduler-调度器,控制所有的调度
Trigger-触发条件,采用DSL模式
JobDetail-需要处理的JOB
Job-执行逻辑

HappenBefore:你写的代码很可能根本没按期望的顺序执行,因为编译器和CPU会
尝试重排指令使得代码更快地进行
执行代码的顺序可能与编写代码不一致,即虚拟机优化顺序,则为指令重排happen-before

volatile
保证线程间变量的可见性
volatile是不错的机制,但是volatile不能保证原子性
轻量的synchronized

ThreadLocal
在多线程环境下,每个线程都有自己的数据,一个线程使用自己的局部变量比使用全局变量好
因为局部变量只有线程自己能看见,不会影响其他线程

可重入锁
如果某个线程视图获取一个已经由它自己持有的锁时
那么这个请求会立刻成功,并且会将这个锁的计数值加1
而当线程退出同步代码块时,计数器将会递减,当计数值等于0时,锁会释放

锁分为两类:
悲观锁:synchronized是独占锁即悲观锁,会导致其他所有需要锁的线程挂起,等待持有锁的线程释放锁
乐观锁:每次不加锁而是假设没有冲突而去完成某项操作,如果因为冲突失败就重试,知道成功为止
Compare and Swap比较并交换:CAS是一组原子操作,不会被外部打断








