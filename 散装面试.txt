一个类如果用一次的情况下,为了提升性能我们可以把做内部类,做内部类的好处随着外部类的使用进行加载
内部类不使用不会编译,使用才会编译

join合并线程,待A此线程执行完成后,再执行B或其他线程,B或其他线程阻塞

守护线程:是为用户线程服务的:jvm停止不用等待守护线程执行完毕

javac是编译器,把java代码编译成字节码
java.exe是指解释器,解释执行字节,java程序编译后产生.class文件也就是说的byte code文件

DLL(Dynamic Link Library)文件即库文件，是动态链接库文件，又称“应用程序拓展”,是软件文件类型

下列说法正确的有(C)
A.class中的constructor不可省略
B.constructor必须与class同名,但方法不能与class同名
C.constructor在对象被new时执行
D.一个class只能定义一个constructor

解析:
A.class中的constructor可以省略，这时类在加载的过程中会自动生成一个无参的constructor,当自己手动添加constructor,类不再自动生成constructor.
B.constructor必须与class同名,方法能与class同名。
例如我创建了一个Person类,类中可以有一个 public int Person（）{} 方法，该方法不是构造方法。
C.使用new关键字实例化对象的时候被实例化的类会调用构造方法来初始化类。
D.一个类中可以有0或0个以上构造方法



下列运算符合法的是(D)
A.&&    B.<>   C.if    D. :=
解析:
A.&& 短路与,Java逻辑运算符,同真则真;
B.<> sql中常用的不等于,Java中不等于用 !=表示;
C.if是一个判定语句,不属于运算符;
D.在go语言中:= 是声明并赋值,并且系统自动推断类型,不需要var关键字 例如:d := 100


下列哪一种叙述是正确的(D)
A.abstract修饰符可修饰字段、方法和类
B.抽象方法的body部分必须用一对大括号{}包住
C.声明抽象方法,大括号可有可无
D.抽象方法不可写出大括号

解析：
A.抽象方法是一种特殊的方法,只有声明,没有函数体。
B.抽象类不能用final来修饰 抽象方法也不能被final修饰
因为被final修饰后抽象类和抽象方法将无法使用即抽象类无法继承,抽象方法无法重写


下列语句正确的是(A)
A.形式参数可被视为local variable
B.形式参数可被字段修饰符修饰
C.形式参数为方法被调用时,真正被传递的参数
D.形式参数不可以是对象

解析：
A.local variable 是一个局部变量,形参和局部变量一样都不能离开方法,都只能在方法内才会发生作用
B.对于形式参数只能被final修饰,其它任何修饰符都会引起编译器错误。但是用这个修饰符也有一定的限制,就是在方法中不能对参数做任何修改。
不过一般情况下,一个方法的形参不用final修饰。只有在特殊情况下,那就是:方法内部类。
一个方法内的内部类如果使用了这个方法的参数或者局部变量的话,这个参数或局部变量应该是final。
C|D.真正被传递是实际参数,形参可以理解成一个装载实际参数的容器
所有的参数传递都是通过对象传递的,实际上传递的是该参数的引用

下列哪种说法是正确的(D)
A.实例方法可直接调用超类的实例方法
B.实例方法可以直接调用超类的类方法
C.实例方法可直接调用其他类的实例方法
D.实例方法可直接调用本类的类方法

解析：
实例方法和类方法的定义与实例变量与类变量的相同,都是通过有无static关键字来进行区分,方法类型前有static的为类方法,反之则为实例方法。
简而言之带static的就是"类"的不带static就是"实例"
实例方法可以调用超类的"非"private方法,并且如果实例方法与超类的实例方法"同名"的时候必须使用"super"调用超类的实例方法

下列说法错误的有:(A C D)
A.在类方法中可用this来调用本类的类方法
B.在类方法中调用本类的类方法式可直接调用
C.在类方法中只能调用本类的类方法
D.在类方法中绝对不能调用实例方法
解析:静态方法中不能使用this关键字

下列说法正确的有(B C D)
A.环境变量可在编译source code时指定
B.在编译程序时,所能执行的环境变量不包括class path
C.javac一次可同时编译数个Java源文件
D.javac.exe能指定编译结果要置于哪个目录下(directoy)
解析：环境变量是指Java JDK的位置,我们在CMD下运行Java程序前,必须先启动这些工具,所有需要在编译source code前指定环境变量。

下列正确的有（ACD）
A.call by value不会改变实际参数的数值
B.call by reference能改变实际参数的参考地址 [引用指向的地址]
C.call by reference不能改变实际参数的参考地址
D.call by reference 能改变实际参数的内容 [最直观的就是对数组进行操作了]

解析:
关于JAVA中参数传递问题有两种,一种是按值传递call by value（如果是基本类型）,另一种是按引用传递call by reference（如果是ο螅.
实际上JAVA中的参数传递全是以值传递的：是基本类型,就拷贝一个基本类型传进方法
是引用,就拷贝一个引用变量传进去方法

实际项目开发中,使用字符串当作主键字段类型比较多
主键:非空+唯一





